{
    "version": "https://jsonfeed.org/version/1",
    "title": "Camber's Logistics | Archive • All posts by \"algorithm\" tag",
    "description": "Camber物流 | 存档处",
    "home_page_url": "https://camber.moe",
    "items": [
        {
            "id": "https://camber.moe/2019/memo-Searching/",
            "url": "https://camber.moe/2019/memo-Searching/",
            "title": "<待整理>关于搜索的笔记",
            "date_published": "2019-02-02T17:50:35.000Z",
            "content_html": "<h1 id=\"XDU-ICPC-搜索Ex-ppt-Memo-Rawα-w-vjudge-2\"><a href=\"#XDU-ICPC-搜索Ex-ppt-Memo-Rawα-w-vjudge-2\" class=\"headerlink\" title=\"XDU_ICPC /搜索Ex.ppt / Memo Rawα /w vjudge_2\"></a>XDU_ICPC /搜索Ex.ppt / Memo Rawα <br>/w vjudge_2</h1><blockquote>\n<p>待整理，或许就不整理了</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>特征明显，容易想出算法</li>\n<li>代码量大，容易出错</li>\n</ul>\n<h2 id=\"状态空间与搜索树\"><a href=\"#状态空间与搜索树\" class=\"headerlink\" title=\"状态空间与搜索树\"></a>状态空间与搜索树</h2><p>&lt;Todo&gt;</p>\n<p>(这个去看XuzhouICPC Memo Day8)(还没写)</p>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><p>状态空间角度: 去重&amp;压缩<br>搜索树角度: 剪</p>\n<blockquote>\n<p><strong>*TODO*</strong> 去看A*</p>\n</blockquote>\n<h2 id=\"博弈-搜索\"><a href=\"#博弈-搜索\" class=\"headerlink\" title=\"博弈 + 搜索\"></a>博弈 + 搜索</h2><ol>\n<li><p>双人零和博弈  </p>\n<blockquote>\n<p>特点: <strong>双方</strong>对抗，<strong>策略最优</strong><br>博弈过程<strong>交替</strong><br>零和: 结果必须为<strong>一方胜利另一方失败</strong>/平局<br>完全信息: 双方都知道完整的状态</p>\n</blockquote>\n<p>其中策略最优要满足: 自己获利最大 &lt;-&gt; 对方获利最小</p>\n</li>\n<li><p>Minimax极大极小搜索(零和博弈)</p>\n<blockquote>\n<p>由零和定义知，在A选择的回合，A想要获利最大，必须选择<strong>使B获利最小</strong>的走法<br>轮到B，同理，B在自己的回合想要使自己的获利最大。双方交替进行   </p>\n</blockquote>\n<p><del>极大极小树的遍历时<strong>自底向上</strong>的，就说怎么一直理解不能</del><br>最终会产出<strong>对于B</strong>的最大/最小层交替出现的树<br>从PPT扒出来的图:  </p>\n<blockquote>\n<p><img src=\"%E5%9B%BE%E7%89%871.png\" alt=\"image\"></p>\n</blockquote>\n<p>在不加以剪枝的情况下，仍然需要遍历树的每一个节点 </p>\n<p>Reference &gt;&gt;&gt;(待补全)   </p>\n<pre><code class=\"python\">def minimax():</code></pre>\n<p>Reference &gt;&gt;&gt; XDOJ 1405</p>\n</li>\n<li><p>α-β剪枝(Minimax)<br><strong>一句话：对搜索过程中存在着不必要的状态，剪掉</strong>  </p>\n<blockquote>\n<p><img src=\"%E5%9B%BE%E7%89%872.png\" alt=\"image\"></p>\n</blockquote>\n<p>针对 <strong>“仍然需要遍历树的每一个节点”</strong> 会出现许多不可能的情况，如选择了一个明显<strong>劣势</strong>的位置(<strong>*劣势</strong>需要实际定义<em>)<br>类似于A</em> 将搜索时间放在更有希望的<strong>子树</strong>上  </p>\n<p>写法：在上述minimax搜索中传递一个α和β变量<br>其中α指max层得到的极大值，β指min层的极小值</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>Negamax负极大值(零和博弈)<br>待补全</li>\n</ol>\n<h2 id=\"精确覆盖问题\"><a href=\"#精确覆盖问题\" class=\"headerlink\" title=\"精确覆盖问题\"></a>精确覆盖问题</h2><ol>\n<li>精确覆盖<br>给定0-1稀疏矩阵，找出一个行集合，使其每列上总共有且只有一个1<br><img src=\"./%E5%9B%BE%E7%89%873.png\" alt=\"image\"></li>\n<li>数独<br>暴力 暴力 暴力 &amp; 精确覆盖的延申 </li>\n<li>N皇后问题<br>回溯 回溯 回溯 &amp; 简化版精确覆盖</li>\n</ol>\n<h3 id=\"精确覆盖的搜索\"><a href=\"#精确覆盖的搜索\" class=\"headerlink\" title=\"精确覆盖的搜索\"></a>精确覆盖的搜索</h3><p>是一个<a href=\"./What-is-NPC.md\">NPC问题</a>&lt;-解释<br>暴力：针对有1的那一行的进行枚举</p>\n<h3 id=\"X算法\"><a href=\"#X算法\" class=\"headerlink\" title=\"X算法\"></a>X算法</h3><p><del>哪里还能找到这么好理解的算法（（（</del></p>\n<p>选择了某一行，就拿走(this + conflict(this))  </p>\n<pre><code>0 0 1 0 1 1 0     0 0 x 0 x x 0  \n1 0 0 1 0 0 1     1 0   1     1     1 0 1 1\n0 1 1 0 0 1 0  -&gt; x              -&gt; 1 0 1 0 -&gt; ...\n1 0 0 1 0 0 0     1 0   1     0     0 1 0 1\n0 1 0 0 0 0 1     0 1   0     1\n0 0 0 1 1 0 1     x</code></pre><p>然后继续搜索，回溯时加回</p>\n<p>优点是减少了搜索规模<br>但是其他东西仍然不尽人意</p>\n<h3 id=\"DancingLinks-X-舞蹈链-a-k-a-DLX-gt-对X-Algorithm的优化\"><a href=\"#DancingLinks-X-舞蹈链-a-k-a-DLX-gt-对X-Algorithm的优化\" class=\"headerlink\" title=\"DancingLinks X 舞蹈链(a.k.a. DLX) -&gt; 对X Algorithm的优化\"></a>DancingLinks X 舞蹈链(a.k.a. DLX) -&gt; 对X Algorithm的优化</h3><p><img src=\"./%E5%9B%BE%E7%89%874.png\" alt=\"image\"><br>如上图，利用链表 快速查找1的位置 &amp;&amp; 快速删除、插入</p>\n<p><del>在ppt里提到的一种数据结构, 由于懒就不写推导过程了</del>  </p>\n<p><a href=\"http://www.cnblogs.com/grenet/p/3145800.html\" target=\"_blank\" rel=\"noopener\">Reference</a>&gt;&gt;&gt;<br>Dancing Links的核心是基于双向链的方便操作（移除、恢复加入）(实现略)  </p>\n<p>将链表的操作应用于 <em>X算法</em> 中，即可得到DancingLinksX数据结构<br>利用链表添加删除O(1)的特点满足X算法的需求，而且矩阵中若1的个数很大，X算法+DLX可以极快的缩小搜索规模</p>\n<p>特点: 每列有一个辅助节点，列节点首有一个head节点<br>节点保存 <strong>上下左右的指针</strong> &lt;- 核心</p>\n<p>运行效率很高，理由：<br>链表的跳转次数取决于矩阵中1的个数<br>如果矩阵中1的个数很多，会被X算法迅速缩小到很小的规模   </p>\n<p>请求裸题&gt;&gt;&gt;</p>\n<p>End</p>\n",
            "tags": [
                "Algorithm",
                "RAW",
                "Memo",
                "Searching"
            ]
        }
    ]
}