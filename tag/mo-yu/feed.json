{
    "version": "https://jsonfeed.org/version/1",
    "title": "Camber's Logistics | Archive • All posts by \"mo-yu\" tag",
    "description": "Camber物流 | 存档处",
    "home_page_url": "https://camber.moe",
    "items": [
        {
            "id": "https://camber.moe/2019/memo-day5-RAW/",
            "url": "https://camber.moe/2019/memo-day5-RAW/",
            "title": "memo.day5.RAW",
            "date_published": "2019-01-27T16:00:00.000Z",
            "content_html": "<p>// C++大法好，我选择Python<br>// D.R.G. == Delete Rayark Games<br>没错我说的就是Cytus II </p>\n<p>Index:<br>数论</p>\n<ul>\n<li>素数</li>\n<li>欧几里得</li>\n<li>同余</li>\n<li>积性函数</li>\n</ul>\n<h1 id=\"Day5-6-数论基础\"><a href=\"#Day5-6-数论基础\" class=\"headerlink\" title=\"Day5/6 / 数论基础\"></a>Day5/6 / 数论基础</h1><h2 id=\"素数-筛法判断\"><a href=\"#素数-筛法判断\" class=\"headerlink\" title=\"素数 - 筛法判断\"></a>素数 - 筛法判断</h2><ol>\n<li><p>埃拉托斯特尼筛法:  </p>\n<blockquote>\n<p>计算整数区间[2，n]中的所有素数的最为简便的筛法<br>预处理时间复杂度为O(n * log log n) 空间复杂度为O(n)<br>合数是作为素数的倍数被筛去  </p>\n</blockquote>\n</li>\n<li><p>欧拉筛法:<br><del>(事实上都写的这个)略</del>代码</p>\n<pre><code class=\"py3\"># Prime Generator with Euler.\nnotPrime = [False]*1000005\nPrime = []\nfor i in range(2,1000005):\n if not notPrime[i]: Prime.append(i)\n for ii in Prime:\n     if ii == 1: continue\n     if i * ii &gt; 1000000: break\n     notPrime[i*ii] = True\n     if i % ii == 0: break</code></pre>\n<p>概括: 欧拉的原理是遍历+乘</p>\n</li>\n<li><p>和素数筛相关的<strong>不要使用Python(cPython)</strong>，会T的飞起，尤其是ZOJ</p>\n</li>\n</ol>\n<h3 id=\"Goldbach-Conjecture\"><a href=\"#Goldbach-Conjecture\" class=\"headerlink\" title=\"Goldbach Conjecture\"></a>Goldbach Conjecture</h3><p>(Link)[localhost]<br>[-] <del>待做题</del> 换OJ过了<br>Python 不适合数据量大的题<br><del>你妈的 为什么</del></p>\n<p>题面:  </p>\n<blockquote>\n<p>每个大于4的偶数可以写成两个奇素数的和。<br>例如：8=3+5，3和5都是奇素数；而20=3+17=7+13；42=5+37=11+31=13+29=19+23。<br>现在哥德巴赫猜想仍然没有被证明是否正确。现在请您证明对所有小于一百万的偶数，哥德巴赫猜想成立  </p>\n</blockquote>\n<dl><dt>做法<br>: 预处理 1 - 数据范围 的素数 存入数组</dt><dd>遍历查询是否都为素数</dd></dl><h3 id=\"Summation-of-Four-Primes\"><a href=\"#Summation-of-Four-Primes\" class=\"headerlink\" title=\"Summation of Four Primes\"></a>Summation of Four Primes</h3><blockquote>\n<dl><dt>每个数字是否可以表示成4个素数的总和<br>[-] Accepted /w c++<br>[-] Summarize<br>[ ] Summarize<br>分析</dt><dd>哥德巴赫猜想的拓展  </dd></dl></blockquote>\n<dl><dt>做法<br>: (类比于哥德巴赫猜想)预处理</dt><dd>遍历查询</dd></dl><h3 id=\"Digit-Prime\"><a href=\"#Digit-Prime\" class=\"headerlink\" title=\"Digit Prime\"></a>Digit Prime</h3><p>[-] 所以Python会T飞 &amp;&amp; C++ AC<br>欧拉<del>欧拉欧拉欧拉欧拉欧拉欧拉</del> <del>(唐突JoJo)</del><br>+ 多离线处理一次</p>\n<h2 id=\"素数-试除法与Miller-Rabin法-同余\"><a href=\"#素数-试除法与Miller-Rabin法-同余\" class=\"headerlink\" title=\"素数 - 试除法与Miller-Rabin法(同余)\"></a>素数 - 试除法与Miller-Rabin法(同余)</h2><p>[ ]待补全</p>\n<h3 id=\"Miller-Rabin\"><a href=\"#Miller-Rabin\" class=\"headerlink\" title=\"Miller-Rabin\"></a>Miller-Rabin</h3><p>[ ]待补全</p>\n<h3 id=\"PrimeSeq\"><a href=\"#PrimeSeq\" class=\"headerlink\" title=\"PrimeSeq\"></a>PrimeSeq</h3><p>[ ]待写题</p>\n<h2 id=\"不定方程和同余方程\"><a href=\"#不定方程和同余方程\" class=\"headerlink\" title=\"不定方程和同余方程\"></a>不定方程和同余方程</h2><h3 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h3><blockquote>\n<dl><dt>线性组合: 如果a和b都是整数，则ax+by是a和b的线性组合，其中数x和y是整数<br>定理<br>: 如果a和b都是整数，且a和b不全为0</dt><dd>则GCD(a, b) 是a和b的线性组合中最小正整数。</dd></dl></blockquote>\n<h3 id=\"最大公约数和不定方程\"><a href=\"#最大公约数和不定方程\" class=\"headerlink\" title=\"最大公约数和不定方程\"></a>最大公约数和不定方程</h3><p>####GCD()<br>代码:  </p>\n<pre><code class=\"py3\">def gcd(a,b):\n    return b if a == 0 else gcd(b%a,a)\n    # a if b == 0 else gcd(b,a%b)</code></pre>\n<dl><dt>证明</dt><dd><strong>关键</strong> 证明<code>gcd(a,b)</code>与<code>gcd(b%a,a)</code>可互相整除  </dd></dl><h4 id=\"Happy-2006\"><a href=\"#Happy-2006\" class=\"headerlink\" title=\"Happy 2006\"></a>Happy 2006</h4><blockquote>\n<p>如果两个正整数的GCD是1，则称这两个正整数是互素的<br>要求: 对于给出的整数m，找到按升序排列的第K个和m互素的整数<br>[ ] 待补完</p>\n</blockquote>\n<p>理解:<br>本题互质分两类: 小于m的和大于m的<br>由题解，对其分析</p>\n<pre><code>1,3,...,n-1\nn+1,n+3,...n-1+n\n2n+1,2n+3,...,n-1+2n\n...</code></pre><p>以此类推，可知其具有周期性<br>+  考虑%==0关系 &lt;-&gt; 坑</p>\n<h4 id=\"exGCD\"><a href=\"#exGCD\" class=\"headerlink\" title=\"exGCD()\"></a>exGCD()</h4><p>[ ]待补完<br>[ ]模逆元</p>\n<p>代码 / Reference 数论的编程实验.pptx p34</p>\n<pre><code class=\"Python\"># Note 模运算的结果一定比双方都小\n# 计算量小可以使用python交题\ndef ext_euclid(a, b):\n     if b == 0: return 1, 0, a  #\n     else: \n         x, y, q = ext_euclid(b, a % b) # q = gcd(a, b) = gcd(b, a%b)\n         # x, y 表示原线性方程的整根\n         # 直到递归到达底层前都不会被处理\n         x, y = y, (x - (a // b) * y)\n         # \n         return x, y, q</code></pre>\n<p>定理:   </p>\n<ol>\n<li><p>定义: 如果a和b都是整数，则ax+by是a和b的<em>线性组合<em>，其中数x和y是整数<br>定理: 如果a和b都是整数，且a和b不全为0，则GCD(a, b) 是a和b的</em>线性组合中最小正整数</em><br>::即对于ax+by, gcd(a,b)为上式最小值</p>\n</li>\n<li><p><strong>Bezout定理</strong>: 如果a和b都是整数，则有整数x和y使得ax+by= GCD(a, b)<br><strong>推论</strong>: 整数a和b互素当且仅当存在整数x和y使得ax+by=1</p>\n</li>\n<li><p>模逆元:</p>\n</li>\n<li><p>定理: 对ax+by=c,设a, b和c都是整数<br>如果c不是GCD(a, b)的倍数，则不定方程ax+by=c没有整数解<br>如果c是GCD(a, b)的倍数，则不定方程ax+by=c有<strong>无穷多</strong>整数解  </p>\n</li>\n<li><p>接上: 如果(x0, y0)是ax+by=c的一个整数解<br>则ax+by=c的所有整数解是x= x0+ k *(b // GCD(a, b))，y= y0-k *(a // GCD(a, b))，其中k是整数</p>\n</li>\n</ol>\n<p>应用/摘抄:</p>\n<blockquote>\n<p>给出ax+by=c 其中a，b和c是整数常量，x和y是整数变量<br>要求计算方程的整数根(x, y)<br>对于不定方程ax+by=c，如果c不是GCD(a, b)的倍数，则不定方程无解<br>否则扩展的欧几里得算法用于求解。</p>\n</blockquote>\n<p>理解: </p>\n<ol>\n<li>在求线性组合ax+by，找a,b的公约数时, 找符合条件的c  </li>\n<li>对方程 ax+by = gcd(a, b)<br>exgcd可以用于求解不定方程的<del>最小</del>整数解 or 判断是否有整数解<br>[-]<del>有且只有一个？</del></li>\n<li></li>\n</ol>\n<h5 id=\"The-equation\"><a href=\"#The-equation\" class=\"headerlink\" title=\"The equation\"></a>The equation</h5><p>[ ] 不想写，没OJ</p>\n<h3 id=\"同余方程和同余方程组\"><a href=\"#同余方程和同余方程组\" class=\"headerlink\" title=\"同余方程和同余方程组\"></a>同余方程和同余方程组</h3><h4 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h4><p>定义1:  </p>\n<blockquote>\n<p>给出一个正整数m和两个整数a和b<br>如果((a-b) %m)=0，则称a和b模m<strong>同余</strong>，记为a≡b(%m)。<br>如果((a-b) %m)!=0，则称a模m不同余于b。</p>\n</blockquote>\n<p>定理:  </p>\n<blockquote>\n<p><strong>定理3.2.2.1.</strong> 给出一个正整数m和两个整数a和b，((a-b) % m)=0当且仅当(iff)存在整数k,a=b+km<br>2. 在一个同余式两边同时做加法、减法或乘法，依然保持同余<br>3. 给出一个正整数m和三个整数a, b和c，a≡b(mod m), 则: a+c≡b+c (mod m); a-c≡b-c (mod m);  ac≡bc (mod m)<br>4. </p>\n</blockquote>\n<p>由上可得出mod法规则:</p>\n<blockquote>\n<p>(a+b)% p= (a%p+b%p)%p &lt;1&gt;<br>(a–b)% p= (a%p–b%p)%p &lt;2&gt;<br>(a*b)% p= (a%p*b%p)%p &lt;3&gt;<br>(a^b)% p= ((a <strong>%p</strong>)^b)%p &lt;4&gt;<br>((a+b)%p+c)%p=(a+(b+c)%p)%p  &lt;5&gt;<br>((ab)%p*c)%p=(a*(bc)%p)%p &lt;6&gt;<br>交换律&lt;7/8&gt;<br>((a +b)% p * c) % p = ((a * c) % p + (b * c) % p) % p &lt;9&gt;  </p>\n</blockquote>\n<h5 id=\"Raising-Modulo-Numbers-破OJ-1995\"><a href=\"#Raising-Modulo-Numbers-破OJ-1995\" class=\"headerlink\" title=\"Raising Modulo Numbers / 破OJ 1995\"></a>Raising Modulo Numbers / 破OJ 1995</h5><blockquote>\n<p>题意: 给出n对数字$A_i$和$B_i$; 以及一个整数M<br>求解: $(A1^B1+A2^B2+…+An^Bn) mod M$<br>输入: Z个测试用例 ,</p>\n</blockquote>\n<p>[ ]题解待写<br>[ ]光靠这题还是搞不懂同余的作用(模法除外)<br>[-]Accepted</p>\n<h4 id=\"一元线性同余方程\"><a href=\"#一元线性同余方程\" class=\"headerlink\" title=\"一元线性同余方程\"></a>一元线性同余方程</h4><blockquote>\n<p>定义3.2.2.2 形如ax≡b(mod m)的<em>同余式</em>被称为<strong>一元线性同余方程，</strong><br>其中a和b是整数，m是正整数，x未知整数  </p>\n<p>定理3.2.2.4 &lt;!关于解&gt; 对关于x的<strong>一元线性同余方程</strong><code>ax≡b(mod m)</code><br>设a和b是整数，m是正整数，且<code>GCD(a, m)==d</code><br>如果<code>b mod d != 0</code>，则ax≡b(mod m)无解<br>如果<code>b mod d == 0</code>，则ax≡b(mod m)恰有<strong>d个模m不同余</strong>的解。  </p>\n<p>推论3.2.2.3 如果GCD(a, m)=1，则一次同余式ax+b≡0(mod m)有解   </p>\n</blockquote>\n<blockquote>\n<p>由定理 3.2.2.4，对于一元线性同余方程ax≡b(mod m)，计算x的算法如下<br>步骤1：应用<strong>欧几里得算法和扩展的欧几里得算法</strong>分别计算d=GCD(a, m)和d=ax’+my’的解(x’, y’)，其中x’是ax’≡d(mod m)的解   &lt;= gcd(a,m)=ax’+my’<br>步骤2：如果b mod d!=0，则ax≡b(mod m)无解；<br>否则存在d个模m不同余的解，其中第一个解$x0=x’*(b DIV d) mod m$<br>其余的d-1解是$xi=(x0+i*(m DIV d)) mod m，1≤i≤d-1$</p>\n</blockquote>\n<h5 id=\"C-Looooooooooooops\"><a href=\"#C-Looooooooooooops\" class=\"headerlink\" title=\"C Looooooooooooops\"></a>C Looooooooooooops</h5><p><strong>有关同余关系的实验</strong><br>题面: POJ 2115  </p>\n<blockquote>\n<p>给出了一个C语言风格类型的循环：</p>\n</blockquote>\n<pre><code class=\"c\">for(variable = A; variable != B; variable += C)\n      statement;</code></pre>\n<blockquote>\n<p>即一个循环(中略)我们要知道语句执行多少次，本题设定所有的算术运算都是在以2k为模的k位无符号整数类型（值0 ≤ x&lt;2k）上进行。  </p>\n</blockquote>\n<p>[ ]同余关系 理解不能</p>\n<h4 id=\"同余方程组\"><a href=\"#同余方程组\" class=\"headerlink\" title=\"同余方程组\"></a>同余方程组</h4><p>中国剩余定理</p>\n<h3 id=\"特殊的同余式\"><a href=\"#特殊的同余式\" class=\"headerlink\" title=\"特殊的同余式\"></a>特殊的同余式</h3><h4 id=\"威尔逊定理和费马小定理\"><a href=\"#威尔逊定理和费马小定理\" class=\"headerlink\" title=\"威尔逊定理和费马小定理\"></a>威尔逊定理和费马小定理</h4><p>引理1:  </p>\n<blockquote>\n<p>p是素数，正整数a是其自身模p的逆当且仅当a≡1(mod p)或a≡-1(mod p)<br>[ ]证明 待补全</p>\n</blockquote>\n<p><strong>威尔逊定理</strong>:</p>\n<blockquote>\n<p>如果p是素数，则(p-1)!≡-1(mod p)<br>== 若p为质数，则p可整除(p-1)!+1</p>\n</blockquote>\n<h4 id=\"YAPTCHA\"><a href=\"#YAPTCHA\" class=\"headerlink\" title=\"YAPTCHA\"></a>YAPTCHA</h4><p>// 原题解析有问题</p>\n<hr>\n<p><strong>费马小定理</strong>  </p>\n<blockquote>\n<p>如果p是素数，a是正整数，且GCD(a, p)=1，则a^(p-1)≡1 (mod p)<br>==&gt;若p为质数&amp;&amp;a,b互质, 则p可整除</p>\n</blockquote>\n<h4 id=\"What-day-is-that-day\"><a href=\"#What-day-is-that-day\" class=\"headerlink\" title=\"What day is that day\"></a>What day is that day</h4><p><strong>伪素数</strong> </p>\n<h4 id=\"欧拉定理-P106\"><a href=\"#欧拉定理-P106\" class=\"headerlink\" title=\"欧拉定理 / P106\"></a>欧拉定理 / P106</h4><p>定义3.3.3.1: 设n是一个正整数。<strong>欧拉𝜑函数$𝜑(n)$</strong>是不超过n且与n互素的正整数的个数<br>定义3.3.3.2: <em>模n</em>的<strong>既约剩余系</strong>是由$𝜑(𝑛)$个整数构成的集合，集合中的<em>每个元素均与n*</em>互素***，且任何两个元素模n不同余。<br>理解: </p>\n<p>定理3.3.1: pass<br>定理3.3.5/欧拉定理: 若n和a互素且为正整数，则$a^(𝜑(𝑛))≡1(mod n)$<br>推论3.3.1: 若n和a互素且为正整数，则$a^(𝜑(𝑛)+1)≡a(mod n)$</p>\n<h2 id=\"积性函数\"><a href=\"#积性函数\" class=\"headerlink\" title=\"积性函数\"></a>积性函数</h2><h3 id=\"欧拉函数\"><a href=\"#欧拉函数\" class=\"headerlink\" title=\"欧拉函数\"></a>欧拉函数</h3><p>定义3.4.1/算术函数: 所有在正整数上运算的函数都被称为算术函数<br>定义3.4.2/积性函数:<br></p>\n<blockquote>\n<p>如果算术函数f对任意两个互素的正整数a和b，f(𝑎𝑏)=𝑓(𝑎)𝑓(𝑏)，则f被称为<strong>积性函数（或乘性函数）</strong><br>如果对任意两个正整数a和b，f(𝑎𝑏)=𝑓(𝑎)𝑓(𝑏)，则f被称为<strong>完全积性函数（或完全乘性函数）</strong>(和上面的不同是没有对<strong>互素</strong>的要求)</p>\n</blockquote>\n<p>由上:<br>定理3.4.1 </p>\n<blockquote>\n<p>如果f是一个积性函数, n是一个正整数, 且n有素幂因子分解n = (p_1)^(a_1)(p_2)^(a_2)…(p_m)^(a_m)<br>则f(n) = f((p_1)^(a_1))f((p_2)^(a_2))..f((p_m)^(a_m))  </p>\n</blockquote>\n<p>定义3.4.3 欧拉函数 见上 + 欧拉函数是一个积性函数<br>定理3.4.2 若a是素数 𝜑(𝑛)=n-1 否则𝜑(𝑛) &lt; n-1<br>定理3.4.3 𝜑函数<strong>公式</strong>: </p>\n<hr>\n<hr>\n<h4 id=\"Relatives\"><a href=\"#Relatives\" class=\"headerlink\" title=\"Relatives\"></a>Relatives</h4><h4 id=\"Primitive-Roots\"><a href=\"#Primitive-Roots\" class=\"headerlink\" title=\"Primitive Roots\"></a>Primitive Roots</h4><h3 id=\"莫比乌斯\"><a href=\"#莫比乌斯\" class=\"headerlink\" title=\"莫比乌斯\"></a>莫比乌斯</h3><h4 id=\"Sky-Code\"><a href=\"#Sky-Code\" class=\"headerlink\" title=\"Sky Code\"></a>Sky Code</h4><p>+容斥原理</p>\n",
            "tags": [
                "Mo-Yu"
            ]
        }
    ]
}